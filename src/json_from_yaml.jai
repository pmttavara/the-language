#import "Basic";
#import "File";
#import "File_Utilities";
#import "Strings";
heap :: #import "Strings_Alloc";

#load "languages.jai";
#load "yaml_snippets.jai";

debug :: false;

// @TODO
// [x] `inline` keyword
// [x] Add setting to control autocompilation
// [x] Fix error diagnostics so that errors always show, along with multiple warnings
// [x] Expand error diagnostics to include addtional locations (wrong split struct example)
// [x] Fix deprecated scrape (for two-line deprecations?)
// [x] Add check on upload.bat the changelog version matches package version and is valid
// [x] Goto next error

// Language Server
// [.] What to do when program is not well formed?
// [x] FoldingRangeProvider
// [x] Projects, build files, etc.
// [x] Finds idents in libraries as well as in project

// Language Server Provider Maybes
// [ ] CompletionItemProvider
// [ ] SignatureHelpProvider
// [ ] TypeDefinitionProvider
// [ ] ImplentationProvider
// [ ] DocumentHighlightProvider
// [ ] DocumentSymbolProvider
// [ ] DocumentLinkProvider

// Misc
// [ ] Change asm help triggering on F12 to something else (context help?) - on F12 it also trigger on ctrl+mouseover
// [ ] Make custom syntax highlighting for #asm
// [ ] Maybe refine asm completions based on features specified
// [ ] Show current proc in status bar
// [ ] Show status in status bar (error state / has reference cache)
// [ ] Show #dump of current proc
// [ ] Add "autogenerated" notation to autogenerated files
// [ ] When in .added_strings, give action to copy strings back into source file (and comment out generating command?)
// [ ] setup tasks.json for module
// [ ] whitespace before MD inner backticks behaves a bit weird
// [ ] markdown codeblock
// [ ] rework all parentheses to begin and end correctly (will fix comments with () in them not highlighting correctly after procedure calls and namespaced deprated functions)
// [.] `#code,null`
// [.] generate @tag comment grammar
// [x] #expand after returns (syntax hghlight)
// [x] Generate `support.function.jai` by scraping Preload et al
// [x] Generate #deprecated pattern by searching procs in jai folder
// [x] fix `number, is_number, leading_zero, c := read_int(format, c);` not marking first two vars as decl
// [x] `#type`, `#c_call`
// [x] `context`, `#no_context`
// [x] anonymous enum/enum_flags/structs
// [x] only start #string when the label is the last thing on the line
// [x] whitespace before `/**`


in_file           :: "jai.yaml";
out_file          :: "../syntaxes/jai.json";
languages_ts_file :: "./languages.ts";

deprecated_extra_names :: string.["temporary_allocator", "__temporary_allocator"];

Language :: struct {
    id      : string;
    source  : string;
    pattern : string;
}

json : String_Builder;
//out :: #bake_arguments print_to_builder(builder = *json);

out :: (format_string : string, args: .. Any) -> bool {
    return print_to_builder(*json, format_string, .. args);
}


tab :: (depth: int) #expand {
    for 0..depth  out("    ");
}


stack : [..] Node_Type;
stack_index := -1;

Node_Type :: enum {
    LIST;
    DICT;
    UNKNOWN;
}

push_stack :: (node_type: Node_Type) {
    stack_index += 1;
    if stack_index >= stack.count
        array_add(*stack, node_type);
    else
        stack[stack_index] = node_type;

}

pop_stack :: () {
    stack_index -= 1;
}

peek_stack :: () -> Node_Type {
    return stack[stack_index];
}

line_number := 0;

Replacement :: struct {
  from : string;
  to : string;
}

replacements : [..] Replacement;

deprecated_names : string = ---;
support_function_names : string = ---;
support_class_names : string = ---;

#run {
    #import "Compiler";
    set_build_options_dc(.{do_output=false});
    main();
}
main :: () {
    args :=  get_command_line_arguments();
    noisey := args.count > 1;

    yaml_file_data, success := read_entire_file(in_file);
    if !success {
        print("Failed to read %", in_file);
        exit(1);
    }

    scrape_modules_folder();

    context.print_style.log_runtime_errors = false;

    languages_ts : String_Builder;
    init_string_builder(*languages_ts);
    append(*languages_ts, "// this file is autogenerated by json_from_yaml.jai - DO NOT EDIT\n\n");
    append(*languages_ts, "export const supportedLanguages = [\n");
    for language: languages
        print_to_builder(*languages_ts, "    [\"%\", /.*%/i],\n", language.id, language.pattern);
    append(*languages_ts, "];\n");
    write_entire_file(languages_ts_file, builder_to_string(*languages_ts));

    yaml : String_Builder;
    init_string_builder(*yaml);
    append(*yaml, yaml_file_data);

    append(*yaml, markdown_block_comments_header);
    for language: languages
        print_to_builder(*yaml, markdown_block_comments_language, language.pattern, language.id, language.source);
    append(*yaml, markdown_block_comments_footer);

    append(*yaml, strings_header);
    for language: languages
        print_to_builder(*yaml, strings_language, language.pattern, language.id, language.source);
    append(*yaml, strings_footer);

    print_to_builder(*yaml, deprecated_names_insert, deprecated_names);
    print_to_builder(*yaml, support_names_insert, support_function_names, support_class_names);
    init_string_builder(*json);

    depth := 0;
    previous_depth := -1;
    close_list_dict := false;
    push_stack(.DICT);
    out("{");

    preprocess : String_Builder;
    init_string_builder(*preprocess);
    line_offsets : [..] int;
    processed_line_count := 0;
    array_add(*line_offsets, 0);

    for raw_row, index: line_split(builder_to_string(*yaml)) {
        row := raw_row;
        line_number = index + 1;

        spaces := 0;
        while spaces < row.count && row[spaces] == #char " "
            spaces += 1;
        if spaces >= row.count {
            line_offsets[processed_line_count] += 1;
            continue;
        }

        if row[spaces] == #char "#" {
            line_offsets[processed_line_count] += 1;

            row = trim_start(advance(row, spaces + 1));
            i := first_index(row, #char ":");
            if i == -1 || i >= row.count - 2 || row[i + 1] != #char ":"
                continue;

            from : string = ---;
            from.data = row.data;
            from.count = i;
            from = trim_end(from);

            to := trim(advance(row, i + 2));

            if row != "" {
                replacement : Replacement = ---;
                replacement.from = from;
                replacement.to = to;
                i := 0;
                while i < replacements.count && replacements[i].from.count > from.count
                    i += 1;
                check := i;
                while check < replacements.count && replacements[check].from.count == from.count {
                    if replacements[check].from == from {
                        print("Duplicate variable label on line %\n", line_number);
                        exit(2);
                    }
                    check += 1;
                }
                array_insert_at(*replacements, replacement, i);
            }

            continue;
        }

        digits_start := spaces;
        digits_end := digits_start;
        while digits_end < row.count && is_digit(row[digits_end])
            digits_end += 1;
        if digits_end > digits_start && row.count > digits_end + 1 && row[digits_end] == #char ":" {
            split_at := digits_end + 1;
            tail := trim(slice(row, split_at + 1));
            if tail != "" {
              append(*preprocess, slice(row, 0, split_at));
              append(*preprocess, "\n");
              for 1 .. spaces + 2  append(*preprocess, " ");
              append(*preprocess, tail);
              append(*preprocess, "\n");
              array_add(*line_offsets, line_offsets[processed_line_count] - 1);
              array_add(*line_offsets, line_offsets[processed_line_count] - 1);
              processed_line_count += 2;
              continue;
            }
        }

        append(*preprocess, row);
        append(*preprocess, "\n");
        array_add(*line_offsets, line_offsets[processed_line_count]);
        processed_line_count += 1;
    }

    yaml_string := builder_to_string(*preprocess);

    for raw_row, index: line_split(yaml_string) {
        row := raw_row;
        line_number = index + 1 + line_offsets[index];
        if noisey  print("% %\n", line_number, row);

        spaces := 0;
        while spaces < row.count && row[spaces] == #char " "
            spaces += 1;
        if spaces >= row.count  continue;
        if spaces % 2 {
            print("Irregular tab indent on line %\n", line_number);
            exit(3);
        }
        depth = spaces / 2;

        if contains_upper_case(row) {
            for replacement: replacements
                row = heap.replace(row, replacement.from, replacement.to);
        }

        key, value, is_list_entry := parse_row(row);

        if peek_stack() == .UNKNOWN {
            if depth <= previous_depth {
                print("Expected indent on line %\n", line_number);
                exit(4);
            }

            tab(previous_depth);

            if is_list_entry {
                stack[stack_index] = .LIST;
                out("[\n");
            }
            else {
                stack[stack_index] = .DICT;
                out("{\n");
            }
        }
        else if previous_depth == depth {
            if is_list_entry && peek_stack() == .LIST {
                out(" },\n");
            }
            else
                out(",\n");
        }
        else if depth > previous_depth && previous_depth >= 0 {
            if peek_stack() != .LIST {
                print("Unexpected indent on line %\n", line_number);
                exit(5);
            }
            out(",\n");
            push_stack(.DICT);
        }
        else {
            while previous_depth > depth {
                out("\n");
                tab(previous_depth - 1);
                if stack[previous_depth] == .LIST {
                    if close_list_dict {
                        out(" }");
                        close_list_dict = false;
                    }
                    out("]");
                }
                else
                    out("}");
                previous_depth -= 1;
                pop_stack();
            }
            if previous_depth == depth
                out(",\n");
            else
                out("\n");
        }

        tab(depth);

        close_list_dict = false;
        if value == "" {
            push_stack(.UNKNOWN);
            out("\"%\":\n", key);
        }
        else {
            if peek_stack() == .LIST {
                out("{ ");
                close_list_dict = true;
            }
            out("\"%\": \"%\"", key, value);
        }

        previous_depth = depth;
    }

    while previous_depth > 0 {
        out("\n");
        tab(previous_depth - 1);
        if stack[previous_depth] == .LIST {
            if close_list_dict {
                out(" }");
                close_list_dict = false;
            }
            out("]");
        }
        else
            out("}");
        previous_depth -= 1;
        pop_stack();
    }
    out("\n}");

    json_string := builder_to_string(*json);
    write_entire_file(out_file, json_string);

    if noisey  for replacements  print("% -> %\n", it.from, it.to);

    set_simd_mode(.OFF); // @TODO remove when we've finished fixing `count`
    print("OK! (% YAML lines -> % JSON lines)\n", count(yaml_string, #char "\n"), count(json_string, #char "\n"));
}


contains_upper_case :: (s: string) -> bool {
    for i: 0 .. s.count - 1
        if is_upper(s[i])
            return true;
    return false;
}

parse_row :: (row_data: string) -> key: string, value: string, is_list_entry: bool {
    row := heap.replace(trim_start(row_data), "\\", "\\\\");

    is_list_entry := false;
    if starts_with(row, "- ") {
        is_list_entry = true;
        row.data += 2;
        row.count -= 2;
    }

    colon := first_index(row, #char ":");
    if colon == -1 {
        print("Missing ':' on line %\n", line_number);
        exit(6);
    }

    key := slice(row, 0, colon);
    value := slice(row, colon + 1);
    value = trim(value);

    key = fix_up(key);
    value = fix_up(value);

    return key, value, is_list_entry;


    fix_up :: (s: string) -> string {
        return heap.replace(trim(s, "'"), "\"", "\\\"");
    }
}


support_module_paths :: string.[
    "c:/jai/modules/Preload.jai",
    "c:/jai/modules/Basic/module.jai",
    "c:/jai/modules/Basic/Array.jai",
    "c:/jai/modules/Basic/Print.jai",
    "c:/jai/modules/Basic/Simple_String.jai",
    "c:/jai/modules/Basic/String_Builder.jai",
    "c:/jai/modules/Basic/string_to_float.jai",
    "c:/jai/modules/Basic/Memory_Debugger.jai",
];


contains :: (haystack: []$T, needle: T) -> bool {
    for haystack  if it == needle  return true;
    return false;
}


scrape_modules_folder :: () {
    files := file_list("c:/jai/modules", recursive = true, follow_symlinks = false);
    for * files {
        if !ends_with(<<it, ".jai") || contains(<<it, "/example")
            remove it;
    }

    deprecated_procs : [..] string;
    support_functions : [..] string;
    support_classes : [..] string;

    for deprecated_extra_names  array_add(*deprecated_procs, it);

    for filepath: files {
        mark := get_temporary_storage_mark();
        defer set_temporary_storage_mark(mark);

        data : string = ---;
        {
            push_allocator(temp);
            data = read_entire_file(filepath);
        }

        if contains(support_module_paths, filepath) {
            exporting := true;
            for line: line_split(data) {
                trimmed := trim(line);
                if trimmed == "#scope_module" || trimmed == "#scope_file" {
                    exporting = false;
                    continue;
                }
                else if trimmed == "#scope_export" {
                    exporting = true;
                    continue;
                }

                if starts_with(line, " ")  continue;

                index, found := first_index(trimmed, "::");
                if !found  continue;

                name := trim(slice(trimmed, 0, index));
                if contains(name, " ")  continue;

                trimmed = trim_end_from(trimmed, "//");
                if contains(trimmed, " struct ") || contains(trimmed, " enum ") || contains(trimmed, " #type ")
                    array_add(*support_classes, heap.copy_string(name));
                else if contains(trimmed, "(")
                    array_add(*support_functions, heap.copy_string(name));
            }
        }

        prev := "";
        for line_split(data) {
            defer prev = it;

            index, found := first_index(it, "#deprecated");
            if !found  continue;

            line := ifx index == 0 then prev else it;

            index, found = first_index(line, "::");
            if !found  continue;

            name := trim(slice(line, 0, index));
            if contains(name, " ")  continue;

            array_add(*deprecated_procs, heap.copy_string(name));
        }
    }

    print("% support functions.\n", support_functions.count);
    print("% support classes.\n", support_classes.count);
    print("% deprecated procs.\n", deprecated_procs.count);

    support_function_names  = heap.join(support_functions, #char "|");
    support_class_names  = heap.join(support_classes, #char "|");
    deprecated_names = heap.join(deprecated_procs, #char "|");
}
